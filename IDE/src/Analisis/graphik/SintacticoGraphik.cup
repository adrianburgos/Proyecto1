//-------------------codigo de usuario-----------------
package Analisis.graphik;
import java_cup.runtime.Symbol;
import Reportes.*;
import fabrica.*;
import ide.Const;
parser code
{:
    public Nodo raiz = new Nodo(); 
    public void syntax_error(Symbol s)
    {
        ErroresGraphik.agregarError("Error sintactico", s.value.toString() + " no debe de ir en esa posicion", s.right, s.left);
    }

    public void unrecovered_syntax_error(Symbol s)
    {
        ErroresGraphik.agregarError("Error sintactico", "No se pudo recuperar de: " + s.value.toString(), s.right, s.left);
    }
:}

//-------------------codigo para acciones gramaticales
action code
{:

:}
//-------------------declaraciones---------------------
terminal var, nuevo, entero, decima, caracter, cadena, bool, vacio, publico, privado, protegido;
terminal importar, extgk, als, hereda, retorna, llamarhk, llamar, inicio, incluirhk, si, sino;
terminal seleccion, defecto, caso, para, mientras, hacer, continuar, terminar, graphikarfuncion;
terminal datos, columna, procesar, donde, dondecada, dondetodo, imprimir;
terminal masmas, menosmenos, mas, menos, por, dividido, pot, and, or, xor, not, menorigual, mayorigual;
terminal menor, mayor, diferente, igualigual, interroga, dospuntos, igual, punto, coma, allave, cllave;
terminal acorchete, ccorchete, aparentesis, cparentesis, puntoycoma;
terminal String numero, iden, cad, car, dec;

non terminal Nodo INICIO, LFUN, FUN, LALS, ALS, CUERPO, HEREDA, VISIBILIDAD, CUERPOALS;
non terminal String OPREL;

//precedencia menor a mayor
precedence left or;
precedence left and;
precedence left menor, mayor, menorigual, mayorigual, diferente, igualigual;
precedence left mas, menos;
precedence left por, dividido, mod;
precedence left pot, sqrt;

precedence left masmas, poslista;
start with INICIO;
//-------------------reglas sintacticas----------------

INICIO          ::= {:System.out.println("inicio");:} LALS:LALS {: raiz = LALS; System.out.println("FINALIZO"); :};

LALS            ::= LALS ALS
                |   ALS;

ALS             ::= als iden HEREDA dospuntos VISIBILIDAD allave CUERPOALS cllave

HEREDA          ::= hereda iden
                |   ;

VISIBILIDAD     ::= publico
                |   protegido
                |   privado;
CUERPOALS
LFUN            ::= LFUN:LFUN FUN:FUN
                    {:
                        if(FUN != null)
                            LFUN.hijos.add(FUN);
                        RESULT = (Nodo) LFUN;
                    :}
                |   FUN:FUN
                    {:
                        RESULT = new Nodo(Const.ldecfun);
                        if(FUN != null) 
                            RESULT = NodoGeneral.crearLdecfun(FUN);
                    :};

OPREL           ::= menor {: RESULT = Const.menor; :}
                |   mayor {: RESULT = Const.mayor; :}
                |   menorigual {: RESULT = Const.menorigual; :}
                |   mayorigual {: RESULT = Const.mayorigual; :}
                |   igualigual {: RESULT = Const.igualigual; :}
                |   diferente {: RESULT = Const.diferente; :};

E               ::= E:t1 mas E:t2 {: RESULT = NodoOperacion.crearNodo(Const.mas, t1, t2); :}
                |   E:t1 or E:t2 {: RESULT = NodoOperacion.crearNodo(Const.or, t1, t2); :}
                |   E:t1 and E:t2 {: RESULT = NodoOperacion.crearNodo(Const.and, t1, t2); :}
                |   E:t1 OPREL:op E:t2 {: RESULT = NodoOperacion.crearRelacional(op, t1, t2); :};
                |   E:t1 menos E:t2 {: RESULT = NodoOperacion.crearNodo(Const.menos, t1, t2); :}
                |   E:t1 por E:t2 {: RESULT = NodoOperacion.crearNodo(Const.por, t1, t2); :}
                |   E:t1 dividido E:t2 {: RESULT = NodoOperacion.crearNodo(Const.dividido, t1, t2); :}
                |   E:t1 mod E:t2 {: RESULT = NodoOperacion.crearNodo(Const.mod, t1, t2); :}
                |   E:t1 pot E:t2 {: RESULT = NodoOperacion.crearNodo(Const.pot, t1, t2); :}
                |   E:t1 sqrt E:t2 {: RESULT = NodoOperacion.crearNodo(Const.sqrt, t1, t2); :}
                |   menos E:t1 {: RESULT = NodoOperacion.crearNodo(Const.unario, t1, null); :}
                |   aparentesis E:t1 cparentesis {: RESULT = t1; :}
                |   OPSIST:t1 {: RESULT = t1; :}
                |   numero:t1 {: RESULT = NodoGeneral.crearHoja(Const.numero, t1); :}
                |   decimal:t1 {: RESULT = NodoGeneral.crearHoja(Const.decimal, t1); :}
                |   iden:t1 {: RESULT = NodoGeneral.crearHoja(Const.id, t1); :}
                |   car:t1 {: RESULT = NodoGeneral.crearHoja(Const.caracter, t1); :}
                |   cad:t1 {: RESULT = NodoGeneral.crearHoja(Const.cadena, t1); :}
                |   LISTA:t1 poslista CALCULAR:CALCULAR {: RESULT = NodoGeneral.crearPosLista(t1, CALCULAR); :}
                |   OPEXP:t1 {: RESULT = t1; :};