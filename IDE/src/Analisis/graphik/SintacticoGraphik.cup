//-------------------codigo de usuario-----------------
package Analisis.graphik;
import java_cup.runtime.Symbol;
import Reportes.*;
import fabrica.*;
import ide.Const;
import semanticos.*;
parser code
{:
    public Nodo raiz = new Nodo(); 
    public void syntax_error(Symbol s)
    {
        ErroresGraphik.agregarError("Error sintactico", s.value.toString() + " no debe de ir en esa posicion", s.right, s.left);
    }

    public void unrecovered_syntax_error(Symbol s)
    {
        ErroresGraphik.agregarError("Error sintactico", "No se pudo recuperar de: " + s.value.toString(), s.right, s.left);
    }
:}

//-------------------codigo para acciones gramaticales
action code
{:

:}
//-------------------declaraciones---------------------
terminal var, nuevo, entero, decimal, caracter, cadena, bool, vacio, publico, privado, protegido;
terminal importar, als, hereda, retornar, llamarhk, llamar, inicio, incluirhk, si, sino;
terminal seleccion, defecto, caso, para, mientras, hacer, continuar, terminar, graphikarfuncion;
terminal datos, columna, procesar, donde, dondecada, dondetodo, imprimir;
terminal masmas, menosmenos, mas, menos, por, dividido, pot, and, or, xor, not, menorigual, mayorigual;
terminal menor, mayor, diferente, igualigual, interroga, dospuntos, igual, punto, coma, allave, cllave;
terminal acorchete, ccorchete, aparentesis, cparentesis;
terminal String numero, dec, iden, cad, car, verdadero, falso, extgk;

non terminal Nodo INICIO, FUN, LALS, ALS, CUERPO, HEREDA, LCUERPOALS, CUERPOALS, LIMPORTAR, VALOR;
non terminal Nodo IMPORTAR, INCLUIR, LID, LVALOR, DEC, PRINCIPAL, LPAR, ASIG, ASIGNORMAL, LCORCHETES, ASIGARR;
non terminal Nodo LLLAVES, LLAVE, LCUERPO, ASIGNACION, SI, SELECCION, PARA, MIENTRAS, HACER, LLAMADO, LLAMADOHK, GRAFICAR;
non terminal Nodo SINO, LCASOS, CASO, DEFECTO, LVARIABLES, PREASIG, ASIGPARA, VALPARA, OP, IMPRIMIR, ACCESO;
non terminal String OPREL, VISIBILIDAD, TIPO, TIPOFUN;

//precedencia menor a mayor
precedence left or;
precedence left xor;
precedence left and;
precedence left not;
precedence left menor, mayor, menorigual, mayorigual, diferente, igualigual;
precedence left mas, menos;
precedence left por, dividido;
precedence right pot;
precedence left masmas, menosmenos;
start with INICIO;
//-------------------reglas sintacticas----------------

INICIO          ::= {:System.out.println("inicio");:} INCLUIR:INCLUIR LALS:LALS
                    {:
                        Nodo RAIZ = new Nodo("raiz");
                        RAIZ.hijos.add(INCLUIR);
                        RAIZ.hijos.add(LALS);
                        raiz = RAIZ;
                        System.out.println("FINALIZO");
                    :};

LID             ::= LID:LID punto iden:nombre
                    {:
                        Nodo id = new Nodo(Const.id, nombre);
                        LID.hijos.add(id);
                        RESULT = (Nodo) LID;
                    :}
                |   iden:nombre
                    {: 
                        Nodo id = new Nodo(Const.id, nombre);
                        RESULT = NodoGeneral.crearLid(id);
                    :};
TIPO            ::= entero {: RESULT = Const.numero; :}
                |   decimal {: RESULT = Const.decimal; :}
                |   caracter {: RESULT = Const.caracter; :}
                |   cadena {: RESULT = Const.cadena; :}
                |   bool {: RESULT = Const.bool; :}
                |   iden:id {: RESULT = id; :};

LVALOR          ::= LVALOR:LVALOR coma VALOR:VALOR
                    {:
                        LVALOR.hijos.add(VALOR);
                        RESULT = (Nodo) LVALOR;
                    :}
                |   VALOR:VALOR {: RESULT = NodoGeneral.crearLvalor(VALOR); :}
                |   {: RESULT = new Nodo(Const.lvalor); :};

INCLUIR         ::= LIMPORTAR:LIMPORTAR {: RESULT = LIMPORTAR; :}
                |   {: RESULT = new Nodo(Const.limportar); :};
LIMPORTAR         ::= LIMPORTAR:LIMPORTAR IMPORTAR:IMPORTAR
                    {:
                        if(IMPORTAR != null)
                            LIMPORTAR.hijos.add(IMPORTAR);
                        RESULT = (Nodo) LIMPORTAR;
                    :}
                |   IMPORTAR:IMPORTAR 
                    {: 
                        RESULT = new Nodo(Const.limportar);
                        if(IMPORTAR != null)
                            RESULT = NodoGeneral.crearLimportar(IMPORTAR);
                    :};
IMPORTAR        ::= importar iden:id extgk:ext interroga {: RESULT = NodoGeneral.crearImportar(id, ext); :}
                |   incluirhk iden:id interroga {: RESULT = NodoGeneral.crearIncluirhk(id); :};

LALS         ::= LALS:LALS ALS:ALS
                    {:
                        if(ALS != null)
                            LALS.hijos.add(ALS);
                        RESULT = (Nodo) LALS;
                    :}
                |   ALS:ALS 
                    {: 
                        RESULT = new Nodo(Const.lals);
                        if(ALS != null)
                            RESULT = NodoGeneral.crearLals(ALS);
                    :};

ALS             ::= als iden:id HEREDA:HEREDA VISIBILIDAD:VISIBILIDAD allave LCUERPOALS:LCUERPOALS cllave
                    {:
                        RESULT = NodoGeneral.crearAls(id, VISIBILIDAD, HEREDA, LCUERPOALS);
                    :};

HEREDA          ::= hereda iden:id {: RESULT = new Nodo(Const.hereda, id); :}
                |   {: RESULT = new Nodo(Const.hereda); :};

VISIBILIDAD     ::= dospuntos publico {: RESULT = Const.publico; :}
                |   dospuntos protegido {: RESULT = Const.protegido; :}
                |   dospuntos privado {: RESULT = Const.privado; :}
                |   {: RESULT = Const.publico; :};

LCUERPOALS      ::= LCUERPOALS:LCUERPOALS CUERPOALS:CUERPOALS
                    {:
                        if(CUERPOALS != null)
                            LCUERPOALS.hijos.add(CUERPOALS);
                        RESULT = (Nodo) LCUERPOALS;
                    :}
                |   CUERPOALS:CUERPOALS
                    {:
                        RESULT = new Nodo(Const.lcuerpoals);
                        if(CUERPOALS != null) 
                            RESULT = NodoGeneral.crearLcuerpoals(CUERPOALS);
                    :};

CUERPOALS       ::= FUN:FUN {: RESULT = FUN; :}
                |   DEC:DEC interroga {: RESULT = DEC; :}
                |   PRINCIPAL:PRINCIPAL {: RESULT = PRINCIPAL; :};

FUN             ::= TIPOFUN:tipo iden:id aparentesis LPAR:LPAR cparentesis VISIBILIDAD:VISIBILIDAD allave LCUERPO:LCUERPO cllave
                    {: RESULT = NodoGeneral.crearFuncion(id, tipo, VISIBILIDAD, LPAR, LCUERPO); :};
TIPOFUN         ::= TIPO:TIPO {: RESULT = TIPO; :}
                |   vacio {: RESULT = Const.vacio; :};

LPAR            ::= LPAR:LPAR coma TIPO:TIPO iden:id
                    {:
                        int t = Semantico.getTipo(TIPO);
                        Nodo par = new Nodo(Const.id, id, t);
                        LPAR.hijos.add(par);
                        RESULT = (Nodo) LPAR;
                    :}
                |   TIPO:TIPO iden:id {: RESULT = NodoGeneral.crearLpar(id, TIPO); :}
                |   {: RESULT = new Nodo(Const.lpar); :};

DEC             ::= var TIPO:TIPO iden:id VISIBILIDAD:VISIBILIDAD PREASIG:PREASIG
                    {:
                        RESULT = NodoGeneral.crearDec(id, TIPO, VISIBILIDAD);
                    :};
PREASIG         ::= LVARIABLES
                |   ASIG
                |   {:RESULT = null;:};
LVARIABLES      ::= LVARIABLES coma iden VISIBILIDAD
                |   coma iden VISIBILIDAD;
ASIG            ::= igual ASIGNORMAL
                |   LCORCHETES ASIGARR;
ASIGNORMAL      ::= VALOR
                |   nuevo iden aparentesis cparentesis;
LCORCHETES      ::= LCORCHETES acorchete VALOR ccorchete
                |   acorchete VALOR ccorchete;
ASIGARR         ::= igual LLLAVES
                |   ;
LLLAVES         ::= LLLAVES coma allave LLAVE cllave
                |   allave LLAVE cllave;
LLAVE           ::= LVALOR
                |   LLLAVES;

PRINCIPAL       ::= vacio inicio aparentesis cparentesis allave LCUERPO cllave;

LCUERPO         ::= LCUERPO:LCUERPO CUERPO:CUERPO
                    {:
                        if(CUERPO != null)
                            LCUERPO.hijos.add(CUERPO);
                        RESULT = (Nodo) LCUERPO;
                    :}
                |   CUERPO:CUERPO 
                    {: 
                        RESULT = new Nodo(Const.lcuerpo);
                        if(CUERPO != null)
                            RESULT = NodoGeneral.crearCuerpo(CUERPO);
                    :};

CUERPO          ::= DEC interroga
                |   ASIGNACION interroga
                |   SI
                |   SELECCION
                |   PARA
                |   MIENTRAS
                |   HACER
                |   LLAMADO interroga
                |   LLAMADOHK interroga
                |   GRAFICAR interroga
                |   IMPRIMIR interroga
                |   retornar VALOR interroga
                |   terminar interroga
                |   continuar interroga
                |   error interroga;

ASIGNACION      ::= LID LCORCHETES igual VALOR
                |   LID igual VALOR;

SI              ::= si aparentesis VALOR cparentesis allave LCUERPO cllave SINO;
SINO            ::= sino allave LCUERPO cllave
                |   ;
SELECCION       ::= seleccion aparentesis LID cparentesis allave LCASOS DEFECTO cllave;
LCASOS          ::= LCASOS CASO
                |   CASO;
CASO            ::= caso VALOR dospuntos LCUERPO;
DEFECTO         ::= defecto dospuntos LCUERPO
                |   ;
PARA            ::= para aparentesis ASIGPARA dospuntos VALOR dospuntos VALPARA cparentesis allave LCUERPO cllave;
ASIGPARA        ::= ASIGNACION
                |   var TIPO iden igual VALOR;
VALPARA         ::= LID OP
                |   ASIGNACION;
OP              ::= masmas
                |   menosmenos;

MIENTRAS        ::= mientras aparentesis VALOR cparentesis allave LCUERPO cllave;

HACER           ::= hacer allave LCUERPO cllave mientras aparentesis VALOR cparentesis;

GRAFICAR        ::= graphikarfuncion aparentesis LID coma LID cparentesis;

LLAMADO         ::= llamar LID:LID aparentesis LVALOR:LVALOR cparentesis {: RESULT = NodoGeneral.crearLlamar(LID, LVALOR); :};

LLAMADOHK       ::= llamarhk iden:id aparentesis LVALOR:LVALOR cparentesis {: RESULT = NodoGeneral.crearLlamado(id, LVALOR); :};

IMPRIMIR        ::= imprimir aparentesis VALOR:VALOR cparentesis {: RESULT = NodoGeneral.crearImprimir(VALOR); :};

VALOR           ::= VALOR:t1 mas VALOR:t2 {: RESULT = NodoOperacion.crearNodo(Const.mas, t1, t2); :}
                |   VALOR:t1 or VALOR:t2 {: RESULT = NodoOperacion.crearNodo(Const.or, t1, t2); :}
                |   VALOR:t1 xor VALOR:t2 {: RESULT = NodoOperacion.crearNodo(Const.xor, t1, t2); :}
                |   VALOR:t1 and VALOR:t2 {: RESULT = NodoOperacion.crearNodo(Const.and, t1, t2); :}
                |   VALOR:t1 OPREL:op VALOR:t2 {: RESULT = NodoOperacion.crearRelacional(op, t1, t2); :}
                |   VALOR:t1 menos VALOR:t2 {: RESULT = NodoOperacion.crearNodo(Const.menos, t1, t2); :}
                |   VALOR:t1 por VALOR:t2 {: RESULT = NodoOperacion.crearNodo(Const.por, t1, t2); :}
                |   VALOR:t1 dividido VALOR:t2 {: RESULT = NodoOperacion.crearNodo(Const.dividido, t1, t2); :}
                |   VALOR:t1 pot VALOR:t2 {: RESULT = NodoOperacion.crearNodo(Const.pot, t1, t2); :}
                |   not VALOR:t1 {: RESULT = NodoOperacion.crearNodo(Const.not, t1, null); :}
                |   menos VALOR:t1 {: RESULT = NodoOperacion.crearNodo(Const.unario, t1, null); :}
                |   aparentesis VALOR:t1 cparentesis {: RESULT = t1; :}
                |   numero:t1 {: RESULT = NodoGeneral.crearHoja(Const.numero, t1); :}
                |   dec:t1 {: RESULT = NodoGeneral.crearHoja(Const.decimal, t1); :}
                |   verdadero:t1 {: RESULT = NodoGeneral.crearHoja(Const.verdadero, t1, Const.tbool); :}
                |   falso:t1 {: RESULT = NodoGeneral.crearHoja(Const.falso, t1, Const.tbool); :}
                |   car:t1 {: RESULT = NodoGeneral.crearHoja(Const.caracter, t1, Const.tcaracter); :}
                |   cad:t1 {: RESULT = NodoGeneral.crearHoja(Const.cadena, t1, Const.tcadena); :}
                |   ACCESO:t1 {: RESULT = t1; :}
                |   LLAMADO:t1 {: RESULT = t1; :}
                |   LLAMADOHK:t1 {: RESULT = t1; :};

ACCESO          ::= LID:LID LCORCHETES:LCORCHETES
                    {:
                        LID.hijos.add(LCORCHETES);
                        RESULT = (Nodo) LID;
                    :}
                |   LID:LID {: RESULT = LID; :};

OPREL           ::= menor {: RESULT = Const.menor; :}
                |   mayor {: RESULT = Const.mayor; :}
                |   menorigual {: RESULT = Const.menorigual; :}
                |   mayorigual {: RESULT = Const.mayorigual; :}
                |   igualigual {: RESULT = Const.igualigual; :}
                |   diferente {: RESULT = Const.diferente; :};